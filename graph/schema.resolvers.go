package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"
	"gqlgen-subscriptions/graph/model"
	"strconv"
	"time"
)

// UpsertUser is the resolver for the upsertUser field.
func (r *mutationResolver) UpsertUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	var user model.User
	n := len(r.Resolver.UserStore)
	id := input.ID

	if id != nil {
		u, ok := r.Resolver.UserStore[*id]
		if !ok {
			return nil, fmt.Errorf("not found")
		}
		u.Name = input.Name
		user = *u
	} else {
		// generate unique id
		nid := strconv.Itoa(n + 1)
		user.ID = nid
		user.Name = input.Name
		r.Resolver.UserStore[nid] = &user
	}
	r.Resolver.UserUpdateEvents <- &user
	return &user, nil
}

// AddFriend is the resolver for the addFriend field.
func (r *mutationResolver) AddFriend(ctx context.Context, userID string, friendID string) (*model.User, error) {
	// Find the user and friend in the data store.
	user, userOk := r.UserStore[userID]
	friend, friendOk := r.UserStore[friendID]

	// If the user or friend was not found, return an error.
	if !userOk {
		return nil, fmt.Errorf("user with ID %s not found", userID)
	}
	if !friendOk {
		return nil, fmt.Errorf("friend with ID %s not found", friendID)
	}

	// Add the friend to the user's list of friends.
	user.Friends = append(user.Friends, friend)

	// Update the user in the data store.
	r.UserStore[userID] = user

	// Send an update to all subscribers.
	r.UserUpdateEvents <- user

	// Return the updated user.
	return user, nil
}

// Placeholder is the resolver for the placeholder field.
func (r *queryResolver) Placeholder(ctx context.Context) (*string, error) {
	str := "Hello World"
	return &str, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	if len(r.Resolver.UserStore) > 0 {
		users := make([]*model.User, 0)
		// eager load all users and their friends (if any) from the data store and return them.
		for idx := range r.Resolver.UserStore {
			user := r.Resolver.UserStore[idx]
			users = append(users, user)
		}
		return users, nil
	}
	return []*model.User{}, nil
}

// UserUpdated is the resolver for the userUpdated field.
func (r *subscriptionResolver) UserUpdated(ctx context.Context) (<-chan *model.User, error) {
	// Create a channel that will be used to send updates to the client.
	updates := make(chan *model.User)

	// This goroutine will run in the background, listening for changes to users.
	// In a real-world application, you would have some event system to hook into.
	go func() {
		defer close(updates)

		// Here you would subscribe to the event system or changes in the data store.
		// For demonstration purposes, let's assume there's a channel or method on the resolver
		// that gets notified of changes, and we'll range over it.
		for {
			select {
			case <-ctx.Done():
				// If the client disconnects, stop the goroutine.
				return
			case userUpdateEvent := <-r.Resolver.UserUpdateEvents:
				// We received a user update event. Send the update to the client.
				updates <- userUpdateEvent
			}
		}
	}()

	return updates, nil
}

// CurrentTime is the resolver for the currentTime field.
func (r *subscriptionResolver) CurrentTime(ctx context.Context) (<-chan *model.Time, error) {
	ch := make(chan *model.Time)

	go func() {
		defer close(ch)

		for {
			time.Sleep(1 * time.Second)
			fmt.Println("Tick")

			currentTime := time.Now()

			t := &model.Time{
				UnixTime:  int(currentTime.Unix()),
				TimeStamp: currentTime.Format(time.RFC3339),
			}

			select {
			case <-ctx.Done():
				// Exit on cancellation
				fmt.Println("Subscription closed.")
				return

			case ch <- t:
				// Our message went through, do nothing
			}

		}
	}()
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
