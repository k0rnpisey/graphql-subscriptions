package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"
	"github.com/edgedb/edgedb-go"
	edgedbmodel "gqlgen-subscriptions/dbschema/model"
	"gqlgen-subscriptions/graph/model"
)

// UpsertUser is the resolver for the upsertUser field.
func (r *mutationResolver) UpsertUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	var user edgedbmodel.User
	query := `SELECT User { id, name, email, password } FILTER .email = <str>$0`
	err := r.Db.QuerySingle(ctx, query, &user, input.Email)
	if err != nil {
		if err.Error() == "edgedb.NoDataError: zero results" {
			var inserted struct {
				id edgedb.UUID
			}
			query = fmt.Sprintf(`
	INSERT User {
		name := '%s',
		email := '%s',
		password := '%s'
}`, input.Name, input.Email, input.Password)
			err = r.Db.QuerySingle(ctx, query, &inserted)
			if err != nil {
				return nil, err
			}
			return &model.User{
				ID:       inserted.id.String(),
				Name:     input.Name,
				Email:    input.Email,
				Password: input.Password,
			}, nil
		}
	}
	return &model.User{
		ID:       user.Id.String(),
		Name:     user.Name,
		Email:    user.Email,
		Password: user.Password,
	}, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, userID string, followingUserID string) (*model.User, error) {
	var user edgedbmodel.User
	query := `SELECT User { id, name, email, password } FILTER .id = <uuid>$0`
	uuid, _ := edgedb.ParseUUID(userID)
	err := r.Db.QuerySingle(ctx, query, &user, uuid)
	if err != nil {
		return nil, err
	}
	var following edgedbmodel.User
	query = `SELECT User { id, name, email, password } FILTER .id = <uuid>$0`
	uuid, _ = edgedb.ParseUUID(followingUserID)
	err = r.Db.QuerySingle(ctx, query, &following, uuid)
	if err != nil {
		return nil, err
	}

	query = `
        WITH
        U := (SELECT default::User FILTER .id = <uuid>$0),
        F := (SELECT default::User FILTER .id = <uuid>$1)
        UPDATE default::User
        FILTER .id = U.id
        SET {
            following += F
        };
    `
	err = r.Db.Execute(ctx, query, user.Id, following.Id)
	if err != nil {
		return nil, err
	}

	// insert notification into the database
	var inserted struct{ id edgedb.UUID }
	query = fmt.Sprintf(`
	INSERT Notification {
		type := '%s',
		message := '%s',
        user := (SELECT User FILTER .id = <uuid>'%s')
	}`, model.NotificationTypeFollower, fmt.Sprintf("%s is now following you", user.Name), followingUserID)
	err = r.Db.QuerySingle(ctx, query, &inserted)
	if err != nil {
		return nil, err
	}

	listener := r.NotificationSubscription[followingUserID]
	notification := model.Notification{
		Type:    model.NotificationTypeFollower,
		Message: fmt.Sprintf("%s is now following you", user.Name),
	}
	if listener != nil {
		listener <- &notification
	}

	return &model.User{
		ID:       user.Id.String(),
		Name:     user.Name,
		Email:    user.Email,
		Password: user.Password,
	}, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	var inserted struct{ id edgedb.UUID }
	query := fmt.Sprintf(`
    INSERT Post {
        title := '%s',
        content := '%s',
		author := (SELECT User FILTER .id = <uuid>'%s')
    }
`, input.Title, input.Content, input.AuthorID)
	err := r.Db.QuerySingle(ctx, query, &inserted)
	// get author
	var author edgedbmodel.User
	query = `SELECT User { id, name, email, password } FILTER .id = <uuid>$0`
	uuid, _ := edgedb.ParseUUID(input.AuthorID)
	err = r.Db.QuerySingle(ctx, query, &author, uuid)
	if err != nil {
		return nil, err
	}
	return &model.Post{
		ID:      inserted.id.String(),
		Title:   input.Title,
		Content: input.Content,
		Author: &model.User{
			ID:    author.Id.String(),
			Name:  author.Name,
			Email: author.Email,
		},
	}, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, input model.UpdatePostInput) (*model.Post, error) {
	var post edgedbmodel.Post
	query := `SELECT Post { id, title, content } FILTER .id = <uuid>$0`
	uuid, _ := edgedb.ParseUUID(input.ID)
	err := r.Db.QuerySingle(ctx, query, &post, uuid)
	if err != nil {
		return nil, err
	}
	post.Title = input.Title
	post.Content = input.Content
	query = `UPDATE Post filter .id = <uuid>$0 SET { title := <str>$1, content := <str>$2 };`
	err = r.Db.Execute(ctx, query, uuid, input.Title, input.Content)
	if err != nil {
		return nil, err
	}
	return &model.Post{
		ID:      post.Id.String(),
		Title:   post.Title,
		Content: post.Content,
		Author:  &model.User{},
	}, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	query := `DELETE Post FILTER .id = <uuid>$0;`
	uuid, _ := edgedb.ParseUUID(id)
	err := r.Db.Execute(ctx, query, uuid)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	var users []edgedbmodel.User
	query := `SELECT User { id, name, email, password }`
	err := r.Db.Query(ctx, query, &users)
	if err != nil {
		return nil, err
	}
	var out []*model.User
	for _, user := range users {
		o := model.User{
			ID:       user.Id.String(),
			Name:     user.Name,
			Email:    user.Email,
			Password: user.Password,
		}
		out = append(out, &o)
	}
	return out, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, email string, password string) (*model.User, error) {
	var user edgedbmodel.User
	query := `SELECT User { id, name, email, password } FILTER .email = <str>$0 AND .password = <str>$1`
	err := r.Db.QuerySingle(ctx, query, &user, email, password)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       user.Id.String(),
		Name:     user.Name,
		Email:    user.Email,
		Password: user.Password,
	}, nil
}

func (r *queryResolver) UserNotifications(ctx context.Context, userID string) ([]*model.Notification, error) {
	var notifications []edgedbmodel.Notification
	query := `SELECT Notification { id, type, message, user } FILTER .user.id = <uuid>$0`
	uuid, _ := edgedb.ParseUUID(userID)
	err := r.Db.Query(ctx, query, &notifications, uuid)
	if err != nil {
		return nil, err
	}
	var out []*model.Notification
	for _, notification := range notifications {
		o := model.Notification{
			ID:      notification.Id.String(),
			Type:    model.NotificationType(notification.Type),
			Message: notification.Message,
		}
		out = append(out, &o)
	}
	return out, nil
}

// Notifications is the resolver for the notifications field.
func (r *queryResolver) Notifications(ctx context.Context) ([]*model.Notification, error) {
	var notifications []edgedbmodel.Notification
	query := `SELECT Notification { id, type, message }`
	err := r.Db.Query(ctx, query, &notifications)
	if err != nil {
		return nil, err
	}
	var out []*model.Notification
	for _, notification := range notifications {
		o := model.Notification{
			ID:      notification.Id.String(),
			Type:    model.NotificationType(notification.Type),
			Message: notification.Message,
		}
		out = append(out, &o)
	}
	return out, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	var posts []edgedbmodel.Post
	query := `SELECT Post { id, title, content }`
	err := r.Db.Query(ctx, query, &posts)
	if err != nil {
		return nil, err
	}
	var out []*model.Post
	for _, post := range posts {
		o := model.Post{
			ID:      post.Id.String(),
			Title:   post.Title,
			Content: post.Content,
			Author:  &model.User{},
		}
		out = append(out, &o)
	}
	return out, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	var post edgedbmodel.Post
	query := `SELECT Post { id, title, content } FILTER .id = <uuid>$0`
	uuid, _ := edgedb.ParseUUID(id)
	err := r.Db.QuerySingle(ctx, query, &post, uuid)
	if err != nil {
		return nil, err
	}
	return &model.Post{
		ID:      post.Id.String(),
		Title:   post.Title,
		Content: post.Content,
		Author:  &model.User{},
	}, nil
}

// Notification is the resolver for the notification field.
func (r *subscriptionResolver) Notification(ctx context.Context, userID string) (<-chan *model.Notification, error) {
	updates := make(chan *model.Notification, 10) // FIXME: 10 is arbitrary
	c := make(chan *model.Notification, 10)
	r.Resolver.NotificationSubscription[userID] = c
	go func() {
		defer close(updates)
		for {
			select {
			case <-ctx.Done():
				// If the client disconnects, stop the goroutine.
				return
			case followerEvent := <-c:
				// We received a user update event. Send the update to the client.
				updates <- followerEvent
			}
		}
	}()
	return updates, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func (r *queryResolver) Feed(ctx context.Context, userID string) ([]*model.Post, error) {
	// return all posts from users that the user is following and the user itself
	var posts []edgedbmodel.Post
	query := `
			WITH
			U := (SELECT default::User FILTER .id = <uuid>$0),
			SELECT Post { id, title, content, author: {id, name} } FILTER .author IN U.following OR .author = U
		`
	uuid, _ := edgedb.ParseUUID(userID)
	err := r.Db.Query(ctx, query, &posts, uuid)
	if err != nil {
		return nil, err
	}
	var out []*model.Post
	for _, post := range posts {
		o := model.Post{
			ID:      post.Id.String(),
			Title:   post.Title,
			Content: post.Content,
		}
		o.Author = &model.User{
			ID:       post.Author.Id.String(),
			Name:     post.Author.Name,
			Email:    post.Author.Email,
			Password: post.Author.Password,
		}
		out = append(out, &o)
	}
	return out, nil
}

type subscriptionResolver struct{ *Resolver }
